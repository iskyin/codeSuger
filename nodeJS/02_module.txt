// 模块机制

commonJS 规范
	JavaScript缺陷：
		1. 没有模块系统
		2. 标准库较少
		3. 没有标准接口
		4. 缺乏包管理系统

	commonJS规范的提出，主要是为了弥补当前javascript没有标准的缺陷


node 与 浏览器 以及 W3C组织 、 ECMAScript 的关系 ：

		       浏览器                        CommonJS
 |-----------------------------||-------------------------------|
   BOM    DOM       ECMAScript    FS  TCP  Stream  Buffer　.....
 |-------------||-----------------------------------------------|
        W3C                            Node


commonJS的模块规范：

	1. 模块引用：
		例如： var math = require("math");
		require() 方法接受模块标识

	2. 模块定义：
		上下文提供require()方法来引入外部模块，
		上下文提供了exports对象用于导出当前模块的方法或者变量，并且他是唯一导出的出口
		在模块中，还存在一个module对象，它代表模块自身，而exports是module的属性

	3. 模块标识：
    	模块标识其实就是传递给require()方法的参数，他必须是符合小驼峰命名的字符串，
    	或者以.、..开头的相对路径，或者绝对路径
    	可以没有文件后缀.js


    在node中引入模块，需要经历3步：
    	（1）路径分析
    	（2）文件定位
    			文件扩展名分析：
    				node会按照：.js   .json   .node 的次序补足扩展名，依次尝试
    			目录分析和包：
    				node再当前目录下查找package.json,通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位
    	（3）编译执行
    			* .js文件： 通过fs模块同步读取文件后编译执行
    			* .node文件：用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件
    			* .json文件：通过fs模块同步读取文件后，用JSON.parse()解析返回结果
    			* 其余扩展名文件：都被当做.js文件载入
    		每个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能

模块分类：
	1. 核心模块：
		编译过程：
			1. 转存为c/c++代码：
				node采用了v8附带的js2c.py工具，将所有内置的JavaScript代码转换成c/c++里的数组，生成node——natives.h头文件
			2. 编译：
				➤ *nix ： c/c++源码 -> g++/gcc -编译源码-> .so文件 -生成.node文件-> 加载.so文件 -dlopen()加载-> 导出给JavaScript		
				➤ Windows ： c/c++源码 -> VC++ -编译源码-> .dll文件 -生成.node文件-> 加载.dll文件 -dlopen()加载-> 导出给JavaScript			

	2. 文件模块（用户编写的模块）：


加载模块的优先级：
	1. 缓存优先
		不论是核心模块还是文件模块，require()方法对相同模块的第二次加载都一律采用缓存优先的方式
		* 因为再尝试的过程中需要调用fs模块同步阻塞式地判断文件是否存在，而node是单线程的，所以会引起性能问题
		➤ 解决方案1：如果是.node和.json文件再传递给require()的表示服中带上扩展名，会加快一点速度
		➤ 解决方案2：同步配合缓存，可以大幅度缓解node单线程中阻塞式调用的的缺陷
    2. 核心模块：
    	编写C/C++扩展模块 前提条件：
    		➤ GYP项目生成工具 ：
    			1. 减少编写跨平台项目文件的工作量
    			2. Node自身的源码就是通过GYP编译的
    		➤ V8引擎C++库 ：
    			* V8是Node自身的动力来源之一
    			* V8自身由C++写成，可以实现JavaScript与C++的相互调用

    		➤ libuv库：
    			* Node自身动力来源之二
    			* node能够实现跨平台的的一个诀窍就是libuv库，这个库是跨平台的一层封装，通过调用一些底层操作，比自己在各个平台下编写实现要高效得多
    		➤ Node内部库：
    			编写C++模块
    				比如： node::ObjectWrap类可以用来包装你的自定义类
    		➤ 其他库：

















